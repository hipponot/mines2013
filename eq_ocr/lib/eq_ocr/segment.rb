require 'RMagick'
require "base64"

class Segmentation
	include Math
	include Magick

	MIN_X = 0
	MAX_X = 1
	MIN_Y = 2
	MAX_Y = 3

	REGRESSION = 80 * PI / 180.0

	# Accepts a 64bit bitmap encoding and associated stroke data, and returns an array of bitmaps to be processed by tesseract
	def segment bitmap_64, stroke_data, t
		img = bin_to_bmp(bitmap_64)

		#Convert json from string into 2d array
		stroke_data = eval(stroke_data)
		stroke_data = compress stroke_data
		all_bounds = get_all_bounds stroke_data

		# Create the array of bitmaps to be returned
		all_bounds.each_with_index do |bounds, index|
			cropped = crop_image(bounds[0], bounds[1], bounds[2], bounds[3], img)
			cropped.write("/tmp/crop#{t}_#{index}.png")
			cropped.write("crop#{t}_#{index}.png")
		end
		puts "Done!"
	end

	def is_fraction? stroke1, stroke2
		x1, y1 = centroid(stroke1)
		x2, y2 = centroid(stroke2)
		
		if x2 - x1 == 0
			return true
		end

		slope = (y2 - y1) / (x2 - x1)
		angle = atan2((y2 - y1) , (x2 - x1))

		if angle.abs > REGRESSION
			return true
		else
			return false
		end
	end

	def overlap? stroke1, stroke2

		bounds1 = get_bounds stroke1
		bounds2 = get_bounds stroke2

		#bounds1[MAX_X] - bounds1[MIN_X] * bounds1[MAX_Y] - bounds1[MIN_X]

		if ((bounds1[MAX_X] >= bounds2[MIN_X] && bounds1[MAX_X] <= bounds2[MAX_X]) || (bounds1[MIN_X] >= bounds2[MIN_X] && bounds1[MIN_X] <= bounds2[MAX_X])) &&
			((bounds1[MAX_Y] >= bounds2[MIN_Y] && bounds1[MAX_Y] <= bounds2[MAX_Y]) || (bounds1[MIN_Y] >= bounds2[MIN_Y] && bounds1[MIN_Y] <= bounds2[MAX_Y]))
			return true
		elsif ((bounds2[MIN_X] >= bounds1[MIN_X] && bounds2[MAX_X] <= bounds1[MAX_X]) && (bounds2[MIN_Y] >= bounds1[MIN_Y] && bounds2[MAX_Y] <= bounds1[MAX_Y]))
			return true
		elsif ((bounds1[MIN_X] >= bounds2[MIN_X] && bounds1[MAX_X] <= bounds2[MAX_X]) && (bounds1[MIN_Y] <= bounds2[MIN_Y] && bounds1[MAX_Y] >= bounds2[MAX_Y]))
			return true
		elsif ((bounds1[MIN_Y] >= bounds2[MIN_Y] && bounds1[MAX_Y] <= bounds2[MAX_Y]) && (bounds1[MIN_X] <= bounds2[MIN_X] && bounds1[MAX_X] >= bounds2[MAX_X]))
			return true
		end

		return false
	end

	# Decodes 64bit encoding of a bitmap and returns an image generated by the binary data
	def bin_to_bmp bitmap_64
		bin = Base64.decode64(bitmap_64)
		img = Image.from_blob(bin)
		return img[0]
	end

	# Determines if two strokes are close enough together (in time) to be considered part of the same char. If they are, they are compressed into one stroke.
	def compress stroke_data, i=0
		eps = 500

		if i >= (stroke_data.length-1)
			return stroke_data
		end

		line1 = stroke_data[i]
		line2 = stroke_data[i+1]

		if line1.length <= 3
			stroke_data.delete_at i
			return compress stroke_data, i
		end

		if line2.length <= 3
			stroke_data.delete_at i+1
			return compress stroke_data, i
		end

		if (is_fraction? line1, line2) || (overlap? line1, line2)
			if i>0
				new_stroke_data = stroke_data[0..i-1]
			else
				new_stroke_data = Array.new
			end
			stroke = line1.concat(line2)
			new_stroke_data << stroke
			if (i+2) < stroke_data.length
				new_stroke_data.concat(stroke_data[i+2..-1])
			end
			return compress new_stroke_data, i
		else
			return compress stroke_data, i+1
		end


		#if (line2[2] - line1[-1]) < eps
		#	if i>0
		#		new_stroke_data = stroke_data[0..i-1]
		#	else
		#		new_stroke_data = Array.new
		#	end
		#	stroke = line1.concat(line2)
		#	new_stroke_data << stroke
		#	if (i+2) < stroke_data.length
		#		new_stroke_data.concat(stroke_data[i+2..-1])
		#	end
		#	return compress new_stroke_data, i
		#else
		#	return compress stroke_data, i+1
		#end
	end

	# Accepts 4 coordinates defining a rectange, and an image (img)
	# Returns the image defined within img by the rectangle parameter
	def crop_image min_x, max_x, min_y, max_y, img
		cropped = img.crop(min_x, min_y, max_x - min_x, max_y - min_y, true)
		bg = Image.new(max_x - min_x + 100, max_y - min_y + 100)
		cropped = bg.composite(cropped, CenterGravity, OverCompositeOp)
		return cropped
	end

	def centroid stroke
		mass = 0
		i = 3

		centroid = Array.new
		centroid << 0 << 0
		stroke[0..-4].each_slice(3) do |point|

			#Centroid = (x1 + x2) / 2
			c_x = (point[0] + stroke[i])/2.0
			c_y = (point[1] + stroke[i + 1])/2.0

			#Length  = sqrt((dx)^2 + (dy)^2)
			length = (((point[0] - stroke[i])**2) + ((point[1] - stroke[i+1])**2))**0.5
			mass += length

			centroid[0] += c_x * length
			centroid[1] += c_y * length 
			#Increment helper index
			i += 3
		end

		#Centroid = sum(C_i*%mass)
		centroid[0] /= mass
		centroid[1] /= mass
		return centroid
	end

	# Accepts a 2d array of stroke data, where each inner array is a single stroke [x,y,t,x,y,t...]
	# Returns a 2d array, where each innner array is the of minima/maxima of x and y coordinates for that stroke [[min_x, max_x, min_y, max_y],[min_x, max_x, min_y, max_y]...]
	def get_all_bounds stroke_data
		all_bounds = Array.new

		stroke_data.each do |inner_array|
			all_bounds << get_bounds(inner_array)
		end

		return all_bounds
	end

	# Returns an array of bounds [x_min, x_max, y_min, y_max] for the stroke
	def get_bounds stroke
		# 2d array to be returned
		#all_bounds = Array.new

		#stroke_data.each do |inner_array|

			# Arrays for storing x and y values for the stroke currently being inspected
		xvals = Array.new
		yvals = Array.new
		stroke.each_slice(3) do |point|
			xvals.push(point[0])
			yvals.push(point[1])
		end
		# A temporary array that stores the min/max x/y for the stroke being inspected
		bounds = Array.new
		bounds << xvals.min << xvals.max << yvals.min << yvals.max

		return bounds
	end
end

